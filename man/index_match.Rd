% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/index_match.R
\name{index_match}
\alias{index_match}
\title{Matching}
\usage{
index_match(x, y, max.distance = 0, ignore.case = F, verbose = F)
}
\arguments{
\item{x}{character vector containing the patterns to be matched in \code{y}.}

\item{y}{character vector where matches are sought.}

\item{max.distance}{numeric vector with different measures of approximativeness.
See \code{\link[base]{agrep}} for details. If a value \code{max.distance=0} is included,
the first match is carried out with the \code{\link[base]{match}} function,
much faster.}

\item{verbose}{logical, if set to TRUE a progress bar, as well as some other info text
is printed on screen.}
}
\value{
A \code{list} with two elements with the same length as the length of \code{x}.
First column, labelled 'index', contains the indices in \code{y} of
every element of \code{x}. Second column, labelled 'distance.value', contains
the value of \code{max.distance} at which the corresponding 'index was found.
When match fails, both columns have an NA value.
}
\description{
Matching
}
\details{
If \code{max.distance} is very high, every string in \code{x} will match almost
anything in \code{y} because we will have allowed for lots of insertions, deletions
and substitutions. In those cases, we keep the first position only, for coherence
with the \code{\link[base]{match}} function.
}
\examples{
# Simple.
i <- index_match(letters[1:10], letters[4:15], max.distance = 0)

# If max.distance is increased, even those different strings match.
i <- index_match(letters[1:10], letters[4:15], max.distance = 2)

# More complicated.
x <- c("january", "feb")
y <- month.name

# Check 'distance.value' column with 'ignore.case' is set.
print(index_match(x, y, max.distance = c(0, .1),ignore.case = F,verbose = T))
print(index_match(x, y, max.distance = c(0, .1),ignore.case = T,verbose = T))

}
